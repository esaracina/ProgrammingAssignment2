setwd()
getwd()
ls
getwd()
dir()
solve(4)
solve(x)
x <- matrix(1:6, nrow =2, ncol =3)
x
solve(x)
x <- matrix(1:6, nrow =2, ncol =2)
x
x <- matrix(1:8, nrow =4, ncol =4)
x
x <- matrix(1:9, nrow =3, ncol =3)
x
solve(x)
x <- matrix(2,6,3,5,6,2,9,0,1, nrow =3, ncol =3)
x
x <- matrix(4:12, nrow= 3, ncol = 3)
x
solve(x)
x <- matrix(4,2,5,3,6,7,3,5,4, nrow= 3, ncol = 3)
a <- matrix(1:4,2,2)
a
solve(a)
a
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(inv)
inv
}
x <- matrix(rnorm(1000000), nrow = 1000)
m <- makeCacheMatrix(x)
stopifnot(identical(m$get(), x))
print(system.time(y  <- cacheSolve(m)))
print(system.time(y1 <- cacheSolve(m)))
stopifnot(identical(y, y1))
z <- solve(x)
stopifnot(identical(y, z))
x1 <- matrix(rnorm(100), nrow = 10)
m$set(x1)
stopifnot(identical(m$get(), x1))
# Check if the cache is unvalidated
# after a set()
y <- cacheSolve(m)
z <- solve(x1)
stopifnot(identical(y, z))
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(inv)
inv
}
a <- matrix(1:4,2,2)
makeCacheMatrix(a)
x <- makeCacheMatrix(a)
x$get()
solve(a)
x <- cacheSolve(a)
y <- cacheSolve(x)
y
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(inv)
inv
}
a <- matrix(1:4,2,2)
a
makeCacheMatrix(a)
x$get()
solve(a)
y <- cacheSolve(x)
y
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
a <- matrix(1:4,2,2)
a
makeCacheMatrix(a)
x$get()
y <- cacheSolve(x)
y
## The following functions can be used to cache, and then retrieve from cached memory, the inverse of a matrix.
## The first function (makeCacheMatrix) creates a "matrix" object that can cache the inverse of itself.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached inverse")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
a <- matrix(1:4,2,2)
a
solve(a)
makeCacheMatrix(a)
x$get()
## The following functions can be used to cache, and then retrieve from cached memory, the inverse of a matrix.
## The first function (makeCacheMatrix) creates a "matrix" object that can cache the inverse of itself.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached inverse")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
a <- matrix(1:4,2,2)
a
solve(a)
makeCacheMatrix(a)
a$get()
x$get()
makeCacheMatrix$get()
## The following functions can be used to cache, and then retrieve from cached memory, the inverse of a matrix.
## The first function (makeCacheMatrix) creates a "matrix" object that can cache the inverse of itself.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached inverse")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
## The following functions can be used to cache, and then retrieve from cached memory, the inverse of a matrix.
## The first function (makeCacheMatrix) creates a "matrix" object that can cache the inverse of itself.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached inverse")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
a <- matrix(1:4,2,2)
a
makeCacheMatrix(a)
x$get()
x$get(a)
makeCacheMatrix(a)
x$get()
a
makeCacheMatrix(a)
## The following functions can be used to cache, and then retrieve from cached memory, the inverse of a matrix.
## The first function (makeCacheMatrix) creates a "matrix" object that can cache the inverse of itself.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the matrix returned by makeCacheMatrix above.
## If the inverse has already been calculated (and the matrix has not changed), then the function
## retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached inverse")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
a <- matrix(1:4,2,2)
X <- cacheMatrix(a)
x <- makeCacheMatrix(a)
x$get()
y <- cacheSolve(x)
y
